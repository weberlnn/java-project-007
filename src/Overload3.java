/**
 * Created by lin on 2016/8/18.
 */
// 自动转换只能在形参和实参之间不能直接匹配时使用，理解这一点很重要。例如，在上述程序
// 的基础上再定义一个使用byte形参的f()，
public class Overload3 {
    void f(byte x) {
        System.out.println("Inside f(byte): " + x);
    }
    void f(int x){
        System.out.println("Inside f(int): " + x);
    }
    void f(double x){
        System.out.println("Inside f(double): " + x);
    }
}
class TypeConv2{
    public static void main(String args[]) {
        Overload3 ob = new Overload3();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
        ob.f(i); // 调用 ob.f(int)
        ob.f(d); // 调用 ob.f(double)
        ob.f(b); // 调用 ob.f(byte)     现在，没有类型转换
        ob.f(s); // 调用 ob.f(int)      类型转换
        ob.f(f); // 调用 ob.f(double)   类型转换
    }
}
/*本例中，因为有一个版本的f()使用了byte实参，所以当使用byte实参来调用f()时，就会调用
f(byte),并不会自动把它转换为int类型。
方法重载支持多态性，因为它是java实现“单接口，多方法”的途径之一。考虑下面的内容，就会理解其中
的原因。在不支持方法重载的语言中，每一种方法必须被赋予一个唯一的名称。然而，你可能经常会对不
同类型的数据实现基本上相同的方法。试一下考虑绝对值函数。在不支持方法重载的语言中，绝对值函数
经常会有三个或者更多版本，每一个都有一个略微不同的名称。例如，在C语言中，函数abs()返回一个整
数的绝对值，labs()返回长整数的绝对值，而fabs()则返回浮点值的绝对值。因为C不支持重载，所以每
一个函数不得不拥有自己的名称，尽管这三个函数本质上完成的功能是一样的。这样一来就使得情况在概念
上变的比实际更复杂了。尽管这三个函数本质上完成的功能是一样的。这样一来就使得情况在概念上变得比
实际更复杂了。尽管这三个函数本质上完成的功能是一致的，但是你依然需要记住三个函数名。而这种情况
在java中就不会出现，因为每一个绝对值方法都可以使用同一个名称。实际上，java的标准类库就包含一个
名为abs()的绝对值方法。该方法被java的Math类重载以处理不同的数值类型。java根据实参的类型来决定
调用何种版本的abs()。
重载的价值在于允许通过使用同一个名称来访问相关的方法。因此，名称ads代表的是要执行的一般动作，而
根据特定的环境选择正确版本的任务则可以交给编译器来完成。作为程序员，你只需要记住要执行的一般操作
即可。通过应用多态性，若干个名称即可减少到一个。尽管这个示例相当简单，但是如果把这一概念扩展开来，
就会发现重载对于管理更为复杂的程序会起到多么大的作用。
当重载一个方法时，该方法的每一个版本都可以执行你所期望的任意活动。虽然被重载的方法之间彼此可以不
相关，然而，从形式上讲，方法重载就意味着一种关系的存在。因此，尽管你可以使用同一个名称重载无关的
方法，但是最好不要这样做。例如，尽管可以使用名称sqr创建方法来返回整数的平方和浮点数的平方根，但
是这两个运算是根本不同的。以这种方式应用方法重载就违背了它的初衷。在实际应用中，你应该只重载紧密
相关的操作。*/
